
# Elasticsearch Clients

In the [last post]() we got Elasticsearch installed, and ran a simple check to ensure that
everything was set up OK.  Now it's time to take a look at some of the client libraries available
for connecting to Elasticsearch.

While getting familiar with the features provided by Elasticsearch, we'll typically try new things out
by making calls directly against the REST API it provides.

If you're writing an application that depends on Elasticsearch, you _could_ write it to do something
similar, making low level HTTP calls against the REST API.  The drawback to this would be the amount
of non-business focused, "plumbing" code you would need to write in order to make these calls.

Luckily, there's a wide variety of
[clients](http://www.elastic.co/guide/en/elasticsearch/client/community/current/clients.html)
available for connecting to Elasticsearch.  Some are provided by [Elastic](https://www.elastic.co/)
(the company behind Elasticsearch), and some are provided by the wider, open-source community.

In this post, we'll take a look at two of the 'official' clients provided by Elastic targeted at
applications built on the .NET framework:

* **Elasticsearch.NET**
* **NEST**

We'll also take a quick look at a Chrome plugin that's _extremely_ useful when making our direct
REST API calls.  It provides a simpler syntax than what's needed when making the same calls using
cURL, as well as other useful capabilities like code suggestions, syntax highlighting, and query
history.

## Elasticsearch.NET

From the [Elasticsearch.NET & NEST Documentation](http://nest.azurewebsites.net/)

> Elasticsearch.Net is a very low level, dependency free, client that has no opinions about how you
> build and represent your requests and responses. It has abstracted enough so that all the
> Elasticsearch API endpoints are represented as methods but not too much to get in the way of how
> you want to build your json/request/response objects. It also comes with builtin,
> configurable/overridable, cluster failover retry mechanisms. Elasticsearch is elastic so why not
> your client?

It's easily installed via NuGet:

```
install-package Elasticsearch.NET
```

To make a connection to a single instance of Elasticsearch, we set up a `ConnectionConfiguration`
object, providing the URI of the instance, and then instantiate an `ElasticsearchClient` with the
newly created configuration:

```
var uri = new Uri("http://localhost:9200");
var config = new ConnectionConfiguration(uri);            
var client = new ElasticsearchClient(config);
```

Now that we have a client, we can use it to make calls against our Elasticsearch instance.  As an example,
if we want to request the same information that we would get by calling:

```
http://localhost:9200?pretty
```

We could make the following request using our client object:

```
var response = client.Info<string>();
Console.WriteLine(response.Response);
```

Under the covers, Elasticsearch.Net is calling the same REST endpoint behind the URL noted above.

Elasticsearch.NET also provides a [SniffingConnectionPool]() that can be used to provide failover
support when one or more nodes within a cluster are unavailable.  We'll look at that in a future
post when we look at Elasticsearch clusters.

## NEST

From the [Elasticsearch.NET & NEST Documentation](http://nest.azurewebsites.net/)

> NEST is a high level client that has the advantage of having mapped all the request and response
> objects, comes with a strongly typed query DSL that maps 1 to 1 with the Elasticsearch query DSL,
> and takes advantage of specific .NET features such as covariant results. NEST internally uses, and
> still exposes, the low level Elasticsearch.Net client.

Like Elasticsearch.Net, NEST can be installed via NuGet:

```
install-package NEST
```

Setting up a basic connection is very similar to the approach in Elasticsearch.Net:

```
var uri = new Uri("http://localhost:9200");
var config = new ConnectionSettings(uri);
var client = new ElasticClient(config);
```

Notice that although they appear _similar_, the configuration and client types are different in the two libraries:

* `ConnectionConfiguration` (Elasticsearch.Net) vs `ConnectionSettings` (NEST)
* `ElasticsearchClient` (Elasticsearch.Net) vs `ElasticClient` (NEST)


Requesting the information returned by the root Elasticsearch instance URL in NEST is as follows:

```
var response = client.RootNodeInfo();
```

Whereas the Elasticsearch.Net info call returns the actual JSON returned by Elasticsearch, the NEST
call returns a strongly typed object of type `IRootInfoResponse`:

```
var response = client.RootNodeInfo();
Console.WriteLine("Status: " + response.Status);
Console.WriteLine("Name: " + response.Name);
Console.WriteLine("Version Number: " + response.Version.Number);
Console.WriteLine("Version Is Snapshot Build: " +
	response.Version.IsSnapShotBuild);
Console.WriteLine("Lucene Version: " + response.Version.LuceneVersion);
Console.WriteLine("Tagline: " + response.Tagline);
```

One nice feature of NEST (arising from the fact that it leverages Elasticsearch.Net under the
covers) is that it exposes its underlying Elasticsearch.Net client on the NEST client interface.
This gives us the ability, if we have a NEST client, to make both high-level NEST and low-level
Elasticsearch.Net calls, as needed:

```
var response1 = client.RootNodeInfo(); // returns typed IRootInfoReponse
var response2 = client.Raw.Info<string>(); // returns raw JSON response
```


(In future posts, client code examples will focus largely on NEST.  In most cases, though, links to
similar code examples for Elasticsearch.NET will be provided.)

## Sense Plugin

[Sense (beta) Chrome Plugin](https://chrome.google.com/webstore/detail/sense-beta/lhjgkmllcaadmopgmanpapmpjgmfcfig)

To do anything useful with Elasticsearch, we'll need to give it some text to work with.  In the
**next post**, we'll start looking at **indexing**, the process of getting data _into_
Elasticsearch.
