# Better in Bulk

In our [last post](http://www.textualdevelopment.com/2015/06/11/you-get-what-you-give/), we learned
how to retrieve a document by id.  Most of our focus in using Elasticsearch, though, will be on
_searching_ for documents matching some _criteria_ rather than retrieving them by id.  Before we
start looking at that, though, we'll need a collection of documents indexed in Elasticsearch that we
can search against.  In this post, we'll look at using the Elasticsearch Bulk API to efficiently
index a large number of documents.



## Bulk REST API

The Elasticsearch bulk API lets us index multiple documents within a single request.  

A bulk indexing request has the following characteristics:

* It consists of an HTTP POST against the `_bulk` REST endpoint.
* The payload of the POST contains one or more 'action specs'.
* Each 'action spec' consists of two lines describing the indexing action to take for a given document.
	* The first line is the action and metadata specification for the request.
	* The second line is the actual source JSON document that we're requesting to index.

As an example, if we wanted to index the first three [albums]() (500 through 498) from the Rolling
Stone 500, we'd use the following request:

```json
POST /_bulk
{ "index": { "_index": "rolling-stone-500", "_type": "album", "_id": "500" } }
{"title": "Aquemini", "url": "http://www.rollingstone.com/music/lists..." }
{ "index": { "_index": "rolling-stone-500", "_type": "album", "_id": "499" } }
{"title": "Live in Cook County Jail", "url": "http://www.rollingstone..." }
{ "index": { "_index": "rolling-stone-500", "_type": "album", "_id": "498" } }
{"title": "The Stone Roses", "url": "http://www.rollingstone.com/music..."}
```

One important thing to note: the _source_ line for each request _must_ be on a single line.

After making the above request, we get the following response back:

```json
{
   "took": 82,
   "errors": false,
   "items": [
      {
         "index": {
            "_index": "rolling-stone-500",
            "_type": "album",
            "_id": "500",
            "_version": 1,
            "status": 201
         }
      },
      {
         "index": {
            "_index": "rolling-stone-500",
            "_type": "album",
            "_id": "499",
            "_version": 1,
            "status": 201
         }
      },
      {
         "index": {
            "_index": "rolling-stone-500",
            "_type": "album",
            "_id": "498",
            "_version": 1,
            "status": 201
         }
      }
   ]
}
```

In the response above, we see that no errors were generated (via the _errors_ field), and are also
able to see some details about each of the indexed documents.  Of particular note is the _status_
value -- in this case, the value of _201_ indicating that each document was created as part of this
request.

If _all_ the documents within our bulk request fall under the same index and type, we can take a
'shorthand' approach by including the index and type in the request URL.  By doing this, we make
these the default index and type used in each of the bulk actions, allowing us to leave those values
out of each individual 'action spec':

```json
POST /rolling-stone-500/album/_bulk
{ "index": { "_id": "500" } }
{"title": "Aquemini", "url": "http://www.rollingstone.com/music/lists..." }
{ "index": { "_id": "499" } }
{"title": "Live in Cook County Jail", "url": "http://www.rollingstone..." }
{ "index": { "_id": "498" } }
{"title": "The Stone Roses", "url": "http://www.rollingstone.com/music..."}
```




* goal : need bulk indexing to efficiently index multiple documents
	* re-indexing
	* batch load from external apps
	* initial loading
	* etc.

* our example: need to load 500 albums

* operations:
	* index
	* create
	* delete
	* update



* [rs 500 bulk load script](https://github.com/rickhaffey/textual-development/blob/master/src/util/rolling-stone-500.es.bulk-load)

## NEST

## Summary

* next post - first search example
