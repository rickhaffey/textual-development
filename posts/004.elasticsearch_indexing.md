# The Index of Our Progress

We're at a point where we need to **get some data _into_ Elasticsearch** so we can start looking at what
it takes to get useful information back _out_.  To do this, we have to answer two questions:

* What **data** do we actually want to work with, and
* What **steps** do we take to get that data into Elasticsearch?

## Data Set

For our data, we'll be using the set of albums in
**[Rolling Stone's 500 Greatest Albums of All Time](http://www.rollingstone.com/music/lists/500-greatest-albums-of-all-time-20120531)**
(from May, 2012.)  This data is nice in that it offers some substantial text blocks -- the album
summaries -- while also providing a set of attributes -- artist, title, release year, etc. -- that offer
some variety for trying out various techniques.

If we were to represent an **album as a JSON document**, it would look something like this:

```json
{
  "title": "/* album title */",
  "url": "/* url of the album in Rolling Stone's 500 Greatest list */",
  "artist": "/* name of artist */",
  "rank": "/* numeric rank in list */",
  "label": "/* name of record label */",
  "year": "/* year album was released */",
  "summary": "/* summary description */",
  "img_url": "/* url of album cover art image */"
}
```

For our example document in this post, we're going to use album #59 from the Rolling Stone listing:
[CCR's "Chronicle Vol. 1"](http://www.rollingstone.com/music/lists/500-greatest-albums-of-all-time-20120531/creedence-clearwater-revival-chronicle-vol-1-20120524).

## Indexing via POST

The simplest way of getting this document into Elasticsearch is by making an indexing request
against the Elasticsearch API using HTTP `POST`:

```json
POST /rolling-stone-500/album
{
  "title": "Chronicle Vol. 1",
  "url": "http://www.rollingstone.com/music/lists/500-greatest-albums-of-all-time-20120531/creedence-clearwater-revival-chronicle-vol-1-20120524",
  "artist": "Creedence Clearwater Revival",
  "rank": 59,
  "label": "Fantasy",
  "year": 1976,
  "summary": "Between 1968 and early 1972, CCR rolled out 13 Top 40 songs, which still stand as the most impressive run of hits made by an American ... ",
  "img_url": "http://assets.rollingstone.com/assets/images/list/c305a673692a96976fce8b404c1bf141b7db621e.jpg"
}
```

Go ahead and give it a try.

If you enter the above into the
[Sense Chrome plugin](http://www.textualdevelopment.com/2015/05/28/connecting-the-dots#sense-plugin)
and execute it, you should see something like the following as output:

```json
{
   "_index": "rolling-stone-500",
   "_type": "album",
   "_id": "AU23IKBIhgIsIPcT67Z8",
   "_version": 1,
   "created": true
}
```

There's alot going on in the input and output above.  Let's break it down a section at a time.

### The Verb and URL

The first things to look at are the HTTP verb and URL of our request:

```json
POST /rolling-stone-500/album
```

(Remember that in its un-abbreviated format, the request URL above would look something like
`http://localhost:9200/rolling-stone-500/album`.)


This part of the request provides some details around how we want our data handled:

* The **first segment of the URL**, _rolling-stone-500_, is the name of the **index** we're making
  our request against.  An Elasticsearch index roughly corresponds to a **database** in the
  relational world.  We're asking to have our album created under the _rolling-stone-500_ index.
* The **second segment of the URL**, _album_, is the name of the **type** of the document we're
  indexing.  An Elasticsearch type corresponds roughly to a **table** in the relational world, and
  captures various details about the structure of the documents within it.  We're asking to have our
  album indexed under the _album_ type.
* In RESTful APIs, a **POST request**:
	* is often made against a URI representing a 'collection resource' (as is the case here),
	* typically represents a request to _create_ a new instance as a member of that collection resource, and
	* does not include a client provided _id_ for the new resource, instead expecting the server to generate one.

### The Payload

The body of our POST is a JSON document that we are requesting to have indexed in Elasticsearch.
An Elasticsearch **document** corresponds loosely with a **row** in a table of a relational
database.  Whereas a relational row has columns of data within it, an Elasticsearch document has
**fields**, represented by the name/value pairs contained within the JSON document.

### The Response

When we put together the verb, URL, and payload, and submit the request, we get a response back that
matches our expectations based on the description above:

* The `_index` of the newly created document is _rolling-stone-500_.
* The `_type` of the document is _album_.
* The `_id` of the document is _AU23IKBIhgIsIPcT67Z8_, a value auto-generated by the server.
* The `_version` of the document is _1_.  (We'll talk more about versioning and concurrency management in a future post.)
* The document was newly created as part of the request, as indicated by the `created` value.

At this point, we've made some decent progress, but you might still have a couple of questions:

* What if we _don't_ want the server to generate the id for our new document, but rather, we'd like to provide our own?
* What if we need to _update_ an existing document?  What approach do we use to do that?

For the two concerns above, 'PUT' requests come to the rescue.

## Indexing via PUT

By way of an example, let's revisit the document we indexed previously.  As part of that indexing
operation, our document was given an auto-generated id of _AU23IKBIhgIsIPcT67Z8_.  In our current
scenario, we're working with a list of albums ranked from 500 to 1.  We might find it useful to use
the _rank_ of each album as its index within Elasticsearch.

To do that, we would need to index our document, but perform a `PUT` request rather than a `POST`:

```json
PUT /rolling-stone-500/album/59
{
    "title": "Chronicle Vol. 1",
    "url": "http://www.rollingstone.com/music/ ... /20120524",
    "artist": "Creedence Clearwater Revival",
    ... 
}
```

Two key differences to notice in the request above as compared to the original `POST`:

* The HTTP verb used is now `PUT`.
* We've included the document id, _59_, as the final segment of the request URL.


Response

```json
{
   "_index": "rolling-stone-500",
   "_type": "album",
   "_id": "59",
   "_version": 1,
   "created": true
}
```

## NEST


```cs
public class Album
{
    public string Title { get; set; }
    public Uri Url { get; set; }
    public string Artist { get; set; }
    public int Rank { get; set; }
    public string Label { get; set; }
    public int Year { get; set; }
    public string Summary { get; set; }
    public Uri ImageUrl { get; set; }
}
```

We'll look at three different styles of making an indexing request using NEST, moving from the most 'verbose' to the most 'fluent'.

As a preliminary step as part of all three approaches, we need to [set up a connection to our Elasticsearch instance using NEST](http://www.textualdevelopment.com/2015/05/28/connecting-the-dots/#nest).

### Explicit IndexRequest

In the first approach, we explicitly instantiate a strongly-typed `IndexRequest`, providing details
about the index and id for our document.  We then pass the request as a parameter to the `Index`
function on our client:

```cs
IIndexRequest<Album> req = new IndexRequest<Album>(album);
req.Index = "rolling-stone-500";
req.Id = "59";

IIndexResponse response = client.Index(req);
```

### Explicit IndexDescriptor Function

In the second approach, we set up a function that will describe our indexing request (using
`IndexDescriptor<T>`), and pass the function as a parameter to our `Index` request:

```cs
Func<IndexDescriptor<Album>, IndexDescriptor<Album>> f = (a) =>
{
    return a
        .Index("rolling-stone-500")
        .Id(59);
};

IIndexResponse response = client.Index(album, f);
```

### IndexDescriptor via Lambda Expression

In our third approach, we use a lambda expression to capture the same details we set up in approach
#2.  This is the most fluent of the three approaches, and it's the mechanism we'll use in most of
our examples going forward:

```cs
IIndexResponse response = client.Index(album, a => a
    .Index("rolling-stone-500")
    .Id(59)
);
```

### IIndexResponse

With all three approaches, the response we get back is of type `IIndexResponse`.  We can then
inspect this object to get various details about the outcome of our request, similar to what we saw
previously in the raw JSON.  As an example, the following code:


```cs
Console.WriteLine("_index: {0}", response.Index);
Console.WriteLine("_type: {0}", response.Type);
Console.WriteLine("_id: {0}", response.Id);
Console.WriteLine("_version: {0}", response.Version);
Console.WriteLine("created: {0}", response.Created);
```

generates the following output:

```
_index: rolling-stone-500
_type: album
_id: 59
_version: 1
created: True
```

## Updates with PUT

You might ask yourself what would happen if we make more than one `PUT` request against the same
indexing URL.  Whereas the first request _creates_ a new document, following request perform
_updates_ to the document.  So, re-running the following code:

```cs
IIndexResponse response = client.Index(album, a => a
    .Index("rolling-stone-500")
    .Id(59)
);

Console.WriteLine("_index: {0}", response.Index);
Console.WriteLine("_type: {0}", response.Type);
...
```

would result in the following output:

```
_index: rolling-stone-500
_type: album
_id: 59
_version: 2
created: False
```

Note the slight change in the output:

* `_version` is now _2_
* `created` is now _False_, indicating an update rather than a create.



## Conclusion

So great, we've finally gotten some data _into_ Elasticsearch.  We've taken a look at a couple of
different approaches for doing that, both via the REST API, as well as using NEST to index data from
within a .NET app.

Now you might ask, "How do we get the data back _out_?"  Well, you're in luck -- we'll take our
first stab at that in the next post.
